<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>GameOfLife.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">assign1</a> &gt; <a href="index.source.html" class="el_package">game</a> &gt; <span class="el_source">GameOfLife.java</span></div><h1>GameOfLife.java</h1><pre class="source lang-java linenums">package game;

import java.awt.*;
import java.util.*;
import java.util.List;

import static java.util.stream.Collectors.*;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public interface GameOfLife {

<span class="fc" id="L14">  public enum CellState {DEAD, ALIVE}</span>

  public static CellState nextCellState(CellState currentState, int numberOfLiveNeighbors) {
<span class="fc bfc" id="L17" title="All 6 branches covered.">    return numberOfLiveNeighbors == 3 || currentState == CellState.ALIVE &amp;&amp; numberOfLiveNeighbors == 2 ?</span>
<span class="fc" id="L18">      CellState.ALIVE : CellState.DEAD;</span>
  }

  public static List&lt;Point&gt; generateSignals(Point position) {
<span class="fc" id="L22">    int x = position.x;</span>
<span class="fc" id="L23">    int y = position.y;</span>

<span class="fc" id="L25">    return List.of(new Point(x - 1, y - 1), new Point(x - 1, y), new Point(x - 1, y + 1),</span>
      new Point(x, y - 1), new Point(x, y + 1),
      new Point(x + 1, y - 1), new Point(x + 1, y), new Point(x + 1, y + 1));
  }

  static List&lt;Point&gt; generateSignalsForPositions(List&lt;Point&gt; points) {
<span class="fc" id="L31">    return points.stream()</span>
<span class="fc" id="L32">      .map(GameOfLife::generateSignals)</span>
<span class="fc" id="L33">      .flatMap(List::stream)</span>
<span class="fc" id="L34">      .collect(toList());</span>
  }

  public static Map&lt;Point, Integer&gt; countSignals(List&lt;Point&gt; rawSignals) {
<span class="fc" id="L38">    return rawSignals.stream().collect(toMap(point -&gt; point, value -&gt; 1, Integer::sum));</span>
  }

  public static List&lt;Point&gt; nextGeneration(List&lt;Point&gt; currentGeneration) {
<span class="fc" id="L42">    Map&lt;Point, Integer&gt; signalCounts = countSignals(generateSignalsForPositions(currentGeneration));</span>
<span class="fc" id="L43">    return signalCounts.keySet().stream()</span>
<span class="fc bfc" id="L44" title="All 2 branches covered.">            .filter(cell -&gt; (nextCellState(</span>
<span class="fc bfc" id="L45" title="All 2 branches covered.">              currentGeneration.contains(cell) ? CellState.ALIVE : CellState.DEAD,</span>
<span class="fc" id="L46">              signalCounts.getOrDefault(cell, 0)</span>
            ) == CellState.ALIVE))
<span class="fc" id="L48">            .collect(toList());</span>
  }

  public static List&lt;Point&gt; getBounds(List&lt;Point&gt; cells) {
<span class="fc bfc" id="L52" title="All 2 branches covered.">    if (cells.isEmpty()) {</span>
<span class="fc" id="L53">      return new ArrayList&lt;Point&gt;();</span>
    }

    int maxX, minX, maxY, minY;
<span class="fc" id="L57">    maxX = minX = cells.get(0).x;</span>
<span class="fc" id="L58">    maxY = minY = cells.get(0).y;</span>

<span class="fc bfc" id="L60" title="All 2 branches covered.">    for (Point p : cells) {</span>
<span class="fc bfc" id="L61" title="All 2 branches covered.">      if (p.x &lt; minX) {</span>
<span class="fc" id="L62">        minX = p.x;</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">      } else if (p.x &gt; maxX) {</span>
<span class="fc" id="L64">        maxX = p.x;</span>
      }
<span class="fc bfc" id="L66" title="All 2 branches covered.">      if (p.y &lt; minY) {</span>
<span class="fc" id="L67">        minY = p.y;</span>
<span class="fc bfc" id="L68" title="All 2 branches covered.">      } else if (p.y &gt; maxY) {</span>
<span class="fc" id="L69">        maxY = p.y;</span>
      }
<span class="fc" id="L71">    }</span>

<span class="fc" id="L73">    Point topLeft = new Point(minX, minY);</span>
<span class="fc" id="L74">    Point bottomRight = new Point(maxX, maxY);</span>
<span class="fc" id="L75">    return List.of(topLeft, bottomRight);</span>
  }

  public static List&lt;Point&gt; parsePoints(String arg) {
<span class="fc" id="L79">    final Pattern POINT_LIST_PATTERN = Pattern.compile(&quot;(\\s*\\(\\s*\\d+\\s*,\\s*\\d+\\s*\\)\\s*)*&quot;);</span>
<span class="fc" id="L80">    final Pattern POINT_PATTERN = Pattern.compile(&quot;(?:\\(\\s*)(\\d+)(?:\\s*,\\s*)(\\d+)(?:\\s*\\))&quot;);</span>

<span class="fc bfc" id="L82" title="All 2 branches covered.">    if (!POINT_LIST_PATTERN.matcher(arg).matches()) return Collections.emptyList();</span>

<span class="fc" id="L84">    Matcher matcher = POINT_PATTERN.matcher(arg);</span>
<span class="fc" id="L85">    Set&lt;Point&gt; points = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">    while (matcher.find()) {</span>
<span class="fc" id="L87">      points.add(new Point(Integer.parseInt(matcher.group(1)), Integer.parseInt(matcher.group(2))));</span>
    }
<span class="fc" id="L89">    return new ArrayList&lt;&gt;(points);</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>